enum FacingDirection
{
  Right,
  Left,
  Up,
  Down,
}

class GridMovement : ZilchComponent
{
  [Dependency]
  var Collider : Collider = null;
  
  [Property]
  var MoveDelay : Real = 0.3;
  
  var Timer : Real = 0.0;
  var Direction : FacingDirection = FacingDirection.Right;
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
  }

  function OnLogicUpdate(event : UpdateEvent)
  {
    this.Timer -= event.Dt;
  }
  
  function MoveRight()
  {
    if(this.Timer > 0.0)
    {
      return;
    }
    
    var offset = Real3(1,0,0);
    var translation = this.Owner.Transform.WorldTranslation;
    
    // Verify that destination is valid
    if(!this.CheckMove(offset))
    {
      return;
    }
    
    // Move and update facing direction
    this.Owner.Transform.WorldTranslation = translation + offset;
    this.Direction = FacingDirection.Right;
    this.Timer = this.MoveDelay;
  }
  
  function MoveLeft()
  {
    if(this.Timer > 0.0)
    {
      return;
    }
    
    var offset = Real3(-1,0,0);
    var translation = this.Owner.Transform.WorldTranslation;
    
    // Verify that destination is valid
    if(!this.CheckMove(offset))
    {
      return;
    }
    
    // Move and update facing direction
    this.Owner.Transform.WorldTranslation = translation + offset;
    this.Direction = FacingDirection.Left;
    this.Timer = this.MoveDelay;
  }
  
  function MoveUp()
  {
    if(this.Timer > 0.0)
    {
      return;
    }
    
    var offset = Real3(0,1,0);
    var translation = this.Owner.Transform.WorldTranslation;
    
    // Verify that destination is valid
    if(!this.CheckMove(offset))
    {
      return;
    }
    
    // Move and update facing direction
    this.Owner.Transform.WorldTranslation = translation + offset;
    this.Direction = FacingDirection.Up;
    this.Timer = this.MoveDelay;
  }
  
  function MoveDown()
  {
    if(this.Timer > 0.0)
    {
      return;
    }
    
    var offset = Real3(0,-1,0);
    var translation = this.Owner.Transform.WorldTranslation;
    
    // Verify that destination is valid
    if(!this.CheckMove(offset))
    {
      return;
    }
    
    // Move and update facing direction
    this.Owner.Transform.WorldTranslation = translation + offset;
    this.Direction = FacingDirection.Down;
    this.Timer = this.MoveDelay;
  }
  
  function CheckMove(offset : Real3) : Boolean
  {
    var collider = this.Owner.Collider;
    var filter = CastFilter();
    filter.IgnoreCog = this.Owner;
    filter.IgnoreGhost = true;
    var results = this.Space.PhysicsSpace.CastCollider(offset, this.Collider, filter);
    //Console.WriteLine(results.Current.ObjectHit.Name);
    return results.IsEmpty;
  }
}
